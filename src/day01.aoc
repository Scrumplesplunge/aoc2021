// Input: up to 2000 integers, one per line.
// Part 1: Count the number of numbers that are larger than the one before them.
// Part 2: Compute sliding window sums of size 3 and repeat part 1.
// Approach: Part 1 is trivial. For part 2, I maintained a window sum variable
// by adding the leading edge and removing the trailing edge, which generalises
// nicely to windows with larger sizes.

import "std/std.aoc" as std;

alias maxNumbers = 2000;
var numNumbers: int64;
var numbers: [maxNumbers]int64;

function readInput(): void {
  // Read the input into a temporary buffer on the stack.
  alias bufferSize = 16384;
  var buffer: [bufferSize]byte;
  var length = read(std.stdin, &buffer as *void, bufferSize);
  // Parse the input into the numbers array.
  if buffer[length - 1] != '\n' { std.die("newline"); }
  var i: []byte = &buffer;
  var end = i + length;
  while i != end {
    if numNumbers == maxNumbers { std.die("too many"); }
    i = std.readInt(i, &numbers[numNumbers]);
    numNumbers = numNumbers + 1;
    if i[0] != '\n' { std.die("syntax"); }
    i = i + 1;
  }
}

function part1(): int64 {
  var timesIncreased = 0;
  for var i = 1; i < numNumbers; i = i + 1 {
    if numbers[i] > numbers[i - 1] { timesIncreased = timesIncreased + 1; }
  }
  return timesIncreased;
}

function part2(): int64 {
  var timesIncreased = 0;
  if numNumbers < 3 { std.die("not enough"); }
  // windowSum is numbers[i - 3] + numbers[i - 2] + numbers[i - 1]
  var windowSum = numbers[0] + numbers[1] + numbers[2];
  for var i = 3; i < numNumbers; i = i + 1 {
    // newSum is numbers[i - 2] + numbers[i - 1] + numbers[i]
    var newSum = windowSum - numbers[i - 3] + numbers[i];
    if newSum > windowSum { timesIncreased = timesIncreased + 1; }
    // Advance windowSum. The invariant is restored after i increments.
    windowSum = newSum;
  }
  return timesIncreased;
}

function main(): int64 {
  readInput();
  std.printInt(part1());
  std.printInt(part2());
  return 0;
}
