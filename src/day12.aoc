import "std/std.aoc" as std;
import "std/strings.aoc" as strings;

alias bufferSize = 256;
var buffer: [bufferSize]byte;
var length: int64;

alias maxCaves = 13;

struct Cave {
  name: []byte;
  big: bool;
  neighbours: [maxCaves]byte;
  numNeighbours: int64;
}

var caves: [maxCaves]Cave;
var numCaves: int64;
var startCave: byte;
var endCave: byte;

function caveIndex(name: []byte): int64 {
  // Search for an existing cave.
  for var i = 0; i < numCaves; i = i + 1 {
    var cave = &caves[i];
    if strings.strncmp(name, cave->name, 6) == 0 { return i; }
  }
  // The cave is not already known, so create a new one.
  if numCaves == maxCaves { std.die("too many caves"); }
  var cave = &caves[numCaves];
  numCaves = numCaves + 1;
  cave->name = name;
  cave->big = std.isUpper(name[0]);
  return numCaves - 1;
}

function joinCaves(aIndex: int64, bIndex: int64): void {
  var a = &caves[aIndex];
  var b = &caves[bIndex];
  var aSize = a->numNeighbours;
  var bSize = b->numNeighbours;
  if aSize == maxCaves || bSize == maxCaves { std.die("too many neighbours"); }
  a->neighbours[aSize] = bIndex as byte;
  a->numNeighbours = aSize + 1;
  b->neighbours[bSize] = aIndex as byte;
  b->numNeighbours = bSize + 1;
}

function readInput(): void {
  length = std.read(std.stdin, &buffer, bufferSize);
  if length == 0 { std.die("empty input"); }
  if buffer[length - 1] != '\n' { std.die("newline"); }
  var i: []byte = &buffer;
  var end = i + length;
  while i != end {
    var a = i;
    while std.isAlpha(i[0]) { i = i + 1; }
    if i[0] != '-' { std.die("syntax"); }
    i[0] = '\0';
    i = i + 1;
    var b = i;
    while std.isAlpha(i[0]) { i = i + 1; }
    if i[0] != '\n' { std.die("syntax"); }
    i[0] = '\0';
    joinCaves(caveIndex(a), caveIndex(b));
    i = i + 1;
  }
  startCave = caveIndex("start") as byte;
  endCave = caveIndex("end") as byte;
}

// Explore the cave network, counting the number of distinct paths that
// start at `caveIndex` and end at `endCave`. When `canRevisit` is true,
// a single small cave may be revisited on any path. Otherwise, only big caves
// may be revisited. `visited` is a bitmap where the ith bit is 1 if cave i has
// already been visited.
function explore(visited: int64, caveIndex: byte, canRevisit: bool): int64 {
  var entry = &exploreCache[visited][caveIndex][canRevisit];
  if !entry->explored {
    entry->count = doExplore(visited, caveIndex, canRevisit) as int32;
    entry->explored = true;
  }
  return entry->count;
}

struct CacheEntry {
  explored: bool;
  count: int32;
}
var exploreCache: [1 << maxCaves][maxCaves][2]CacheEntry;

// Populate a cache entry for explore().
function doExplore(visited: int64, caveIndex: byte, canRevisit: bool): int64 {
  if caveIndex == endCave { return 1; }  // There's only one path end -> end.
  var cave = &caves[caveIndex];
  var caveBit = 1 << caveIndex;
  if (visited & caveBit) != 0 {
    // The start cave may never be revisited.
    if caveIndex == startCave { return 0; }
    // Small caves can only be revisited if canRevisit is still true.
    if !cave->big {
      if !canRevisit { return 0; }
      canRevisit = false;
    }
  }
  // Consider all distinct paths leading to the `endCave` via any path that
  // exits from `cave`.
  visited = visited | caveBit;
  var n = cave->numNeighbours;
  var total = 0;
  for var i = 0; i < n; i = i + 1 {
    total = total + explore(visited, cave->neighbours[i], canRevisit);
  }
  return total;
}

function main(): int64 {
  readInput();
  std.printInt(explore(0, startCave, false));
  std.printInt(explore(0, startCave, true));
}
