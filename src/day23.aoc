import "std/std.aoc" as std;

// #############
// #...........#
// ###.#.#.#.###
//   #.#.#.#.#
//   #########

struct Vector {
  x: byte;
  y: byte;
}

var input: [16]Vector;

function validate(template: []byte, value: []byte): bool {
  for var i = 0; template[i] != '\0'; i = i + 1 {
    var t = template[i];
    var c = value[i];
    if t == '?' {
      if c != 'A' && c != 'B' && c != 'C' && c != 'D' { return false; }
    } else {
      if t != c { return false; }
    }
  }
  return true;
}

function readInput(): void {
  alias bufferSize = 128;
  var buffer: [bufferSize]byte;
  var length = std.read(std.stdin, &buffer, bufferSize);
  if length == 0 { std.die("empty"); }
  if buffer[length - 1] != '\n' { std.die("newline"); }
  if !validate(
      "#############\n#...........#\n###?#?#?#?###\n  #?#?#?#?#\n  #########\n",
      &buffer) {
    std.die("invalid input");
  }
  var counts: [4]int64;
  for var i = 0; i < 4; i = i + 1 { counts[i] = 0; }
  for var x = 3; x < 11; x = x + 2 {
    for var y = 2; y < 4; y = y + 1 {
      var type = buffer[14 * y + x] - 'A';
      var count = &counts[type];
      if *count == 2 { std.die("too many of one type"); }
      var position = &input[4 * *count + type];
      position->x = x as byte;
      position->y = y as byte;
      *count = *count + 1;
    }
  }
}

struct Node {
  cells: [16]Vector;
  cost: int64;
  next: *any;  // *Node
}

alias maxNodes = 1048576;
var nodes: [maxNodes]Node;
var numNodes: int64;

function newNode(): *Node {
  if numNodes == maxNodes { std.die("too many nodes"); }
  var node = &nodes[numNodes];
  numNodes = numNodes + 1;
  return node;
}

function updateNode(
    node: *Node, i: int64, x: int64, y: int64, costDelta: int64): *Node {
  var n = newNode();
  *n = *node;
  n->cells[i].x = x as byte;
  n->cells[i].y = y as byte;
  n->cost = n->cost + costDelta;
  return n;
}

alias maxHeapSize = 65536;
var heap: [maxNodes]*Node;
var heapSize: int64;

alias setBuckets = 262144;
var set: [setBuckets]*Node;

// The number of amphipods that we are currently trying to solve for.
var numAmphipods: int64;

function reset(n: int64): void {
  heapSize = 0;
  numNodes = 0;
  for var i = 0; i < setBuckets; i = i + 1 { set[i] = null; }
  numAmphipods = n;
}

function hash(node: *Node): int64 {
  var c: []Vector = &node->cells;
  var id = 123456789;
  for var i = 0; i < numAmphipods; i = i + 1 {
    id = (id * 131) ^ (c[i].x << 4 | c[i].y);
  }
  return id % setBuckets;
}

function equal(a: []Vector, b: []Vector): bool {
  for var i = 0; i < 8; i = i + 1 {
    if a[i].x != b[i].x || a[i].y != b[i].y { return false; }
  }
  return true;
}

function add(node: *Node): bool {
  var key = hash(node);
  for var i = set[key]; i != null; i = i->next as *Node {
    if equal(&node->cells, &i->cells) { return false; }
  }
  node->next = set[key];
  set[key] = node;
  return true;
}

function push(node: *Node): void {
  if heapSize == maxHeapSize { std.die("heap too large"); }
  var i = heapSize;
  heapSize = heapSize + 1;
  while i > 0 {
    var p = (i - 1) / 2;
    if heap[p]->cost <= node->cost { break; }
    heap[i] = heap[p];
    i = p;
  }
  heap[i] = node;
}

function pop(): *Node {
  if heapSize == 0 { std.die("empty"); }
  heapSize = heapSize - 1;
  var node = heap[0];
  var last = heap[heapSize];
  var i = 0;
  while true {
    var l = 2 * i + 1;
    if l >= heapSize { break; }
    var c = l + 1 < heapSize && heap[l + 1]->cost < heap[l]->cost ? l + 1 : l;
    if heap[c]->cost >= last->cost { break; }
    heap[i] = heap[c];
    i = c;
  }
  heap[i] = last;
  return node;
}

function isOrganized(state: []Vector): bool {
  for var i = 0; i < numAmphipods; i = i + 1 {
    if state[i].x != targetX(i) { return false; }
  }
  return true;
}

function targetX(i: int64): int64 { return 3 + 2 * (i % 4); }

function toMap(node: *Node): [7][14]byte {
  var map: [7][14]byte;
  for var y = 0; y < 7; y = y + 1 {
    for var x = 0; x < 14; x = x + 1 {
      map[y][x] = 0 as byte;
    }
  }
  for var i = 0; i < numAmphipods; i = i + 1 {
    var p = node->cells[i];
    map[p.y][p.x] = (1 + i % 4) as byte;
  }
  return map;
}

function isCorridorBlocked(map: [][14]byte, start: int64, end: int64): bool {
  var step = start < end ? -1 : 1;
  for var x = end; x != start; x = x + step {
    if map[1][x] != 0 { return true; }
  }
  return false;
}

function isStuckInRoom(map: [][14]byte, v: Vector): bool {
  for var y = v.y - 1; y > 1; y = y - 1 {
    if map[y][v.x] != 0 { return true; }
  }
  return false;
}

function roomIncorrectlyPopulated(map: [][14]byte, i: int64): bool {
  var type = 1 + i % 4;
  var x = targetX(i);
  var yMax = 1 + numAmphipods / 4;
  for var y = 2; y <= yMax; y = y + 1 {
    var v = map[y][x];
    if v != 0 && v != type { return true; }
  }
  return false;
}

function validHallwayPositions(): [14]bool {
  var map: [14]bool;
  for var i = 0; i < 14; i = i + 1 { map[i] = true; }
  map[0] = false;
  map[3] = false;
  map[5] = false;
  map[7] = false;
  map[9] = false;
  map[12] = false;
  return map;
}

function unitCosts(): [8]int16 {
  var costs: [8]int16;
  var value = 1;
  for var i = 0; i < 4; i = i + 1 {
    for var j = 0; j < 2; j = j + 1 {
      costs[4 * j + i] = value as int16;
    }
    value = 10 * value;
  }
  return costs;
}

function solve(input: [16]Vector): int64 {
  var n = numAmphipods / 4;
  var validStop = validHallwayPositions();
  var unitCost = unitCosts();
  var root = newNode();
  root->cells = input;
  root->cost = 0;
  push(root);
  while true {
    if heapSize == 0 { std.die("impossible"); }
    var node = pop();
    if !add(node) { continue; }
    if isOrganized(&node->cells) { return node->cost; }
    var map = toMap(node);
    // Consider all ways that each Amphipod could move.
    for var i = 0; i < numAmphipods; i = i + 1 {
      var type = 1 + i % 4;
      var p = node->cells[i];
      if p.y == 1 {
        // The Amphipod is in the hall, so the only valid moves would be to move
        // into the target room. Skip if the room entrance is occupied.
        var tx = targetX(i);
        if isCorridorBlocked(&map, p.x, tx) ||
           roomIncorrectlyPopulated(&map, i) {
          continue;
        }
        // Scan the room for the furthest slot that isn't occupied.
        var ty = 1;
        while ty <= n && map[ty + 1][tx] == 0 { ty = ty + 1; }
        if ty == 1 { continue; }
        var dy = ty - 1;
        var dx = tx < p.x ? p.x - tx : tx - p.x;
        push(updateNode(node, i, tx, ty, unitCost[i] * (dx + dy)));
      } else {
        // The Amphipod is in a room. Without loss of generality, we can
        // consider only moves that go into the hall: moves between rooms can be
        // considered as moves to the hall followed by moves from the hall. The
        // Amphipod should only move if they are in the wrong room, or if they
        // are obstructing the path of an Amphipod that is in the wrong room.
        if p.x == targetX(i) && !roomIncorrectlyPopulated(&map, i) { continue; }
        if isStuckInRoom(&map, p) { continue; }
        for var x = p.x - 1; x >= 1; x = x - 1 {
          if map[1][x] != 0 { break; }  // Obstructed.
          if validStop[x] {
            push(updateNode(node, i, x, 1, unitCost[i] * (p.y - 1 + p.x - x)));
          }
        }
        for var x = p.x + 1; x <= 11; x = x + 1 {
          if map[1][x] != 0 { break; }  // Obstructed.
          if validStop[x] {
            push(updateNode(node, i, x, 1, unitCost[i] * (p.y - 1 + x - p.x)));
          }
        }
      }
    }
  }
}

function part1(): int64 {
  reset(8);
  return solve(input);
}

function part2(): int64 {
  var copy = input;
  for var i = 0; i < 8; i = i + 1 {
    var v = &copy[i];
    if v->y == 3 { v->y = 5 as byte; }
  }
  // #############
  // #...........#
  // ###?#?#?#?###
  //   #D#C#B#A#    <- 11, 10,  9,  8
  //   #D#B#A#C#    <- 15, 13, 12, 14
  //   #?#?#?#?#
  //   #########
  copy[8].x  = 9 as byte; copy[8].y  = 3 as byte;
  copy[9].x  = 7 as byte; copy[9].y  = 3 as byte;
  copy[10].x = 5 as byte; copy[10].y = 3 as byte;
  copy[11].x = 3 as byte; copy[11].y = 3 as byte;
  copy[12].x = 7 as byte; copy[12].y = 4 as byte;
  copy[13].x = 5 as byte; copy[13].y = 4 as byte;
  copy[14].x = 9 as byte; copy[14].y = 4 as byte;
  copy[15].x = 3 as byte; copy[15].y = 4 as byte;
  reset(16);
  return solve(copy);
}

function main(): int64 {
  readInput();
  std.printInt(part1());
  std.printInt(part2());
}
