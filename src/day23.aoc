import "std/std.aoc" as std;

// #############
// #...........#
// ###.#.#.#.###
//   #.#.#.#.#
//   #########

struct Vector {
  x: byte;
  y: byte;
}

var input: [16]Vector;

function validate(template: []byte, value: []byte): bool {
  for var i = 0; template[i] != '\0'; i = i + 1 {
    var t = template[i];
    var c = value[i];
    if t == '?' {
      if c != 'A' && c != 'B' && c != 'C' && c != 'D' { return false; }
    } else {
      if t != c { return false; }
    }
  }
  return true;
}

function readInput(): void {
  alias bufferSize = 128;
  var buffer: [bufferSize]byte;
  var length = std.read(std.stdin, &buffer, bufferSize);
  if length == 0 { std.die("empty"); }
  if buffer[length - 1] != '\n' { std.die("newline"); }
  if !validate(
      "#############\n#...........#\n###?#?#?#?###\n  #?#?#?#?#\n  #########\n",
      &buffer) {
    std.die("invalid input");
  }
  var counts: [4]int64;
  for var i = 0; i < 4; i = i + 1 { counts[i] = 0; }
  for var x = 3; x < 11; x = x + 2 {
    for var y = 2; y < 4; y = y + 1 {
      var type = buffer[14 * y + x] - 'A';
      var count = &counts[type];
      if *count == 2 { std.die("too many of one type"); }
      var position = &input[4 * *count + type];
      position->x = x as byte;
      position->y = y as byte;
      *count = *count + 1;
    }
  }
  // debug(&input);
}

function cell(c: byte): byte { return c == 0 ? '.' : c; }
function debug(state: []Vector, n: int64): void {
  var output =
    *"#############\n#...........#\n###.#.#.#.###\n  #.#.#.#.#  \n  #.#.#.#.#  \n  #.#.#.#.#  \n  #########\n";
  var numAmphipods = 4 * n;
  for var i = 0; i < numAmphipods; i = i + 1 {
    var p = state[i];
    output[14 * p.y + p.x] = ('A' + i % 4) as byte;
  }
  std.write(std.stdout, &output, std.strlen(&output));
}

struct Node {
  cells: [16]Vector;
  cost: int64;
}

alias maxNodes = 1048576;
var nodes: [maxNodes]Node;
var numNodes: int64;

struct SetNode {
  cells: [16]Vector;
  next: *any;  // *SetNode
}

alias maxSetNodes = 1048576;
var setNodes: [maxSetNodes]SetNode;
var numSetNodes: int64;
alias setBuckets = 1048576;
var set: [setBuckets]*SetNode;

// The number of amphipods that we are currently trying to solve for.
var numAmphipods: int64;

function reset(n: int64): void {
  numSetNodes = 0;
  numNodes = 0;
  for var i = 0; i < setBuckets; i = i + 1 { set[i] = null; }
  numAmphipods = n;
}

function hash(node: *Node): int64 {
  var c: []Vector = &node->cells;
  var id = 123456789;
  for var i = 0; i < numAmphipods; i = i + 1 {
    id = (id * 131) ^ (c[i].x << 4 | c[i].y);
  }
  return id % setBuckets;
}

function equal(a: []Vector, b: []Vector): bool {
  for var i = 0; i < 8; i = i + 1 {
    if a[i].x != b[i].x || a[i].y != b[i].y { return false; }
  }
  return true;
}

function add(node: *Node): bool {
  var key = hash(node);
  for var i = set[key]; i != null; i = i->next as *SetNode {
    if equal(&node->cells, &i->cells) { return false; }
  }
  if numSetNodes == maxSetNodes { std.die("too many set nodes"); }
  var s = &setNodes[numSetNodes];
  numSetNodes = numSetNodes + 1;
  s->cells = node->cells;
  s->next = set[key];
  set[key] = s;
  return true;
}

function push(node: *Node): void {
  if numNodes == maxNodes { std.die("too many nodes"); }
  var i = numNodes;
  numNodes = numNodes + 1;
  while i > 0 {
    var p = (i - 1) / 2;
    if nodes[p].cost <= node->cost { break; }
    nodes[i] = nodes[p];
    i = p;
  }
  nodes[i] = *node;
  // if !checkHeap(0, 0) { std.die("broken after push"); }
  // std.puts("== push ==");
  // std.printInt(node.cost);
  // debug(&node.cells);
}

function pop(): Node {
  if numNodes == 0 { std.die("empty"); }
  numNodes = numNodes - 1;
  var node = nodes[0];
  var last = nodes[numNodes];
  var i = 0;
  while true {
    var l = 2 * i + 1;
    if l >= numNodes { break; }
    var c = l + 1 < numNodes && nodes[l + 1].cost < nodes[l].cost ? l + 1 : l;
    if nodes[c].cost >= last.cost { break; }
    nodes[i] = nodes[c];
    i = c;
  }
  nodes[i] = last;
  // std.printInt(node.cost);
  // if !checkHeap(0, 0) { std.die("broken after pop"); }
  // std.puts("== pop ==");
  // std.printInt(node.cost);
  // debug(&node.cells);
  return node;
}

function checkHeap(p: int64, i: int64): bool {
  if i >= numNodes { return true; }
  var v = nodes[i].cost;
  if v < p { return false; }
  return checkHeap(v, 2 * i + 1) && checkHeap(v, 2 * i + 2);
}

function isOrganized(state: []Vector): bool {
  for var i = 0; i < numAmphipods; i = i + 1 {
    if state[i].x != targetX(i) { return false; }
  }
  return true;
}

function targetX(i: int64): int64 { return 3 + 2 * (i % 4); }

function toMap(node: *Node): [7][14]byte {
  var map: [7][14]byte;
  for var y = 0; y < 7; y = y + 1 {
    for var x = 0; x < 14; x = x + 1 {
      map[y][x] = 0 as byte;
    }
  }
  for var i = 0; i < numAmphipods; i = i + 1 {
    var p = node->cells[i];
    map[p.y][p.x] = (1 + i % 4) as byte;
  }
  return map;
}

function isCorridorBlocked(map: [][14]byte, start: int64, end: int64): bool {
  var step = start < end ? -1 : 1;
  for var x = end; x != start; x = x + step {
    if map[1][x] != 0 { return true; }
  }
  return false;
}

function isStuckInRoom(map: [][14]byte, v: Vector): bool {
  for var y = v.y - 1; y > 1; y = y - 1 {
    if map[y][v.x] != 0 { return true; }
  }
  return false;
}

function roomIncorrectlyPopulated(map: [][14]byte, i: int64): bool {
  var type = 1 + i % 4;
  var x = targetX(i);
  var yMax = 1 + numAmphipods / 4;
  for var y = 2; y <= yMax; y = y + 1 {
    var v = map[y][x];
    if v != 0 && v != type { return true; }
  }
  return false;
}

function validHallwayPositions(): [14]bool {
  var map: [14]bool;
  for var i = 0; i < 14; i = i + 1 { map[i] = true; }
  map[0] = false;
  map[3] = false;
  map[5] = false;
  map[7] = false;
  map[9] = false;
  map[12] = false;
  return map;
}

function unitCosts(): [8]int16 {
  var costs: [8]int16;
  var value = 1;
  for var i = 0; i < 4; i = i + 1 {
    for var j = 0; j < 2; j = j + 1 {
      costs[4 * j + i] = value as int16;
    }
    value = 10 * value;
  }
  return costs;
}

function solve(input: [16]Vector): int64 {
  var n = numAmphipods / 4;
  var validStop = validHallwayPositions();
  var unitCost = unitCosts();
  nodes[0].cells = input;
  nodes[0].cost = 0;
  numNodes = 1;
  while true {
    if numNodes == 0 { std.die("impossible"); }
    var node = pop();
    if !add(&node) {
      // std.puts("already explored");
      continue;
    }
    if isOrganized(&node.cells) { return node.cost; }
    var map = toMap(&node);
    // Consider all ways that each Amphipod could move.
    for var i = 0; i < numAmphipods; i = i + 1 {
      var type = 1 + i % 4;
      var p = node.cells[i];
      // std.printInt(i);
      if p.y == 1 {
        // The Amphipod is in the hall, so the only valid moves would be to move
        // into the target room. Skip if the room entrance is occupied.
        var tx = targetX(i);
        if isCorridorBlocked(&map, p.x, tx) ||
           roomIncorrectlyPopulated(&map, i) {
          // std.puts("skip move: corridor blocked");
          continue;
        }
        // Scan the room for the furthest slot that isn't occupied.
        var ty = 1;
        while ty <= n && map[ty + 1][tx] == 0 { ty = ty + 1; }
        if ty == 1 {
          // std.puts("skip move: room blocked");
          continue;
        }
        var newNode = node;
        newNode.cells[i].x = tx as byte;
        newNode.cells[i].y = ty as byte;
        var dy = newNode.cells[i].y - 1;
        var dx = tx < p.x ? p.x - tx : tx - p.x;
        newNode.cost = newNode.cost + unitCost[i] * (dy + dx);
        push(&newNode);
      } else {
        // The Amphipod is in a room. Without loss of generality, we can
        // consider only moves that go into the hall: moves between rooms can be
        // considered as moves to the hall followed by moves from the hall. The
        // Amphipod should only move if they are in the wrong room, or if they
        // are obstructing the path of an Amphipod that is in the wrong room.
        if p.x == targetX(i) && !roomIncorrectlyPopulated(&map, i) { continue; }
        if isStuckInRoom(&map, p) { continue; }
        var newNode = node;
        newNode.cells[i].y = 1 as byte;
        for var x = p.x - 1; x >= 1; x = x - 1 {
          if map[1][x] != 0 { break; }  // Obstructed.
          if validStop[x] {
            newNode.cells[i].x = x as byte;
            newNode.cost = node.cost + unitCost[i] * ((p.y - 1) + (p.x - x));
            push(&newNode);
          }
        }
        for var x = p.x + 1; x <= 11; x = x + 1 {
          if map[1][x] != 0 { break; }  // Obstructed.
          if validStop[x] {
            newNode.cells[i].x = x as byte;
            newNode.cost = node.cost + unitCost[i] * ((p.y - 1) + (x - p.x));
            push(&newNode);
          }
        }
      }
    }
  }
}

function part1(): int64 {
  reset(8);
  return solve(input);
}

function part2(): int64 {
  var copy = input;
  for var i = 0; i < 8; i = i + 1 {
    var v = &copy[i];
    if v->y == 3 { v->y = 5 as byte; }
  }
  // #############
  // #...........#
  // ###?#?#?#?###
  //   #D#C#B#A#    <- 11, 10,  9,  8
  //   #D#B#A#C#    <- 15, 13, 12, 14
  //   #?#?#?#?#
  //   #########
  copy[8].x  = 9 as byte; copy[8].y  = 3 as byte;
  copy[9].x  = 7 as byte; copy[9].y  = 3 as byte;
  copy[10].x = 5 as byte; copy[10].y = 3 as byte;
  copy[11].x = 3 as byte; copy[11].y = 3 as byte;
  copy[12].x = 7 as byte; copy[12].y = 4 as byte;
  copy[13].x = 5 as byte; copy[13].y = 4 as byte;
  copy[14].x = 9 as byte; copy[14].y = 4 as byte;
  copy[15].x = 3 as byte; copy[15].y = 4 as byte;
  // debug(&copy, 4);
  reset(16);
  return solve(copy);
}

function main(): int64 {
  readInput();
  std.printInt(part1());
  std.printInt(part2());
}
