import "std/std.aoc" as std;

alias maxSideLength = 100;
alias gridSize = 512;

// Storage for the grid, with space for a border of 9 around all sides. The
// border simplifies the processing for each cell as we can always assume the
// presence of neighbours, and a neighbour with height 9 is equivalent to having
// no neighbour.
var grid: [gridSize][gridSize]byte;

// The width and height of the grid, excluding the border.
var gridWidth: int64;
var gridHeight: int64;

function readInput(): void {
  alias bufferSize = 16384;
  var buffer: [bufferSize]byte;
  var length = std.read(std.stdin, &buffer, bufferSize);
  if buffer[length - 1] != '\n' { std.die("newline"); }
  var i: []byte = &buffer;
  var end = i + length;
  while i[gridWidth] != '\n' { gridWidth = gridWidth + 1; }
  if gridWidth > maxSideLength { std.die("too wide"); }
  while i != end {
    if gridHeight == maxSideLength { std.die("too tall"); }
    var row = &grid[gridHeight];
    gridHeight = gridHeight + 1;
    for var x = 0; x < gridWidth; x = x + 1 {
      var value = i[x];
      if value < '0' || '9' < value { std.die("invalid cell"); }
      (*row)[x] = (value - '0') as byte;
    }
    if i[gridWidth] != '\n' { std.die("expected line end"); }
    i = i + (gridWidth + 1);
  }
}

struct Node {
  x: int16;
  y: int16;
  score: int32;
}

var visited: [gridSize][gridSize]bool;
// The maximum difference between the minimum score in the queue and the maximum
// score in the queue is 9: we can add at most 9 to the score of the current
// node under consideration, and we consider nodes in ascending order of score.
alias numBuckets = 16;
// The theoretical maximum number of frontier nodes that have the same score is
// the maximum perimeter of some connected subset of the grid, which could be
// huge in contrived examples. We'll assume that it is no larger than the
// perimeter of the grid itself.
alias stackLimit = 2048;
// Represent the priority queue as a collection of stacks. Stack i stores the
// frontier nodes that have i == score % numBuckets. Since the range between the
// minimum frontier element and the maximum frontier element is bounded at 9, we
// never have to worry about conflicts: every element in a given bucket will
// have exactly the same score.
var stacks: [numBuckets][stackLimit]Node;
var stackSizes: [numBuckets]int64;
var headBucket: int64;
var lastPop: int64;

function initSearch(endX: int64, endY: int64): void {
}

function queuePush(x: int64, y: int64, score: int64): void {
  if visited[y][x] { return; }
  // if score < lastPop || lastPop + 10 < score { std.die("bug"); }
  var bucket = score % numBuckets;
  var i = stackSizes[bucket];
  if i == stackLimit { std.die("too many nodes with the same score"); }
  var node = &stacks[bucket][i];
  node->x = x as int16;
  node->y = y as int16;
  node->score = score as int32;
  stackSizes[bucket] = i + 1;
}

function queuePop(): Node {
  while stackSizes[headBucket] == 0 {
    headBucket = (headBucket + 1) % numBuckets;
  }
  var size = &stackSizes[headBucket];
  var i = *size - 1;
  *size = i;
  // lastPop = stacks[headBucket][i].score;
  return stacks[headBucket][i];
}

function search(endX: int64, endY: int64): int64 {
  // Reset the frontier state.
  lastPop = 0;
  headBucket = 0;
  for var i = 0; i < numBuckets; i = i + 1 { stackSizes[i] = 0; }
  // Reset the visited set.
  for var y = 0; y <= endY; y = y + 1 {
    for var x = 0; x <= endX; x = x + 1 {
      visited[y][x] = false;
    }
  }
  // Perform a search over the space in order of increasing score. The search
  // starts at the *end* and searches backwards for the beginning, because this
  // simplifies some of the bookkeeping.
  queuePush(endX, endY, 0);
  while true {
    var node = queuePop();
    if visited[node.y][node.x] { continue; }
    visited[node.y][node.x] = true;
    if node.x == 0 && node.y == 0 { return node.score; }
    var score = node.score + grid[node.y][node.x];
    if node.x > 0 { queuePush(node.x - 1, node.y, score); }
    if node.x < endX { queuePush(node.x + 1, node.y, score); }
    if node.y > 0 { queuePush(node.x, node.y - 1, score); }
    if node.y < endY { queuePush(node.x, node.y + 1, score); }
  }
}

function part1(): int64 {
  return search(gridWidth - 1, gridHeight - 1);
}

function part2(): int64 {
  // Build the larger grid.
  for var tileY = 0; tileY < 5; tileY = tileY + 1 {
    var offsetY = gridHeight * tileY;
    for var tileX = 0; tileX < 5; tileX = tileX + 1 {
      var offsetX = gridWidth * tileX;
      var delta = tileX + tileY;
      if tileX == 0 && tileY == 0 { continue; }
      for var y = 0; y < gridHeight; y = y + 1 {
        for var x = 0; x < gridWidth; x = x + 1 {
          var risk = grid[y][x] + delta;
          if risk > 9 { risk = risk - 9; }  // Risk level wraps 10 -> 1, not 0.
          grid[y + offsetY][x + offsetX] = risk as byte;
        }
      }
    }
  }
  return search(5 * gridWidth - 1, 5 * gridHeight - 1);
}

function main(): int64 {
  readInput();
  std.printInt(part1());
  std.printInt(part2());
}
