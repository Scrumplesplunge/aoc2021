import "std/std.aoc" as std;
import "std/strings.aoc" as strings;

struct Vector {
  x: int16;
  y: int16;
  z: int16;
  pad: int16;
}

alias maxBeacons = 1024;
var beacons: [maxBeacons]Vector;
var numBeacons: int64;

struct Scanner {
  beacons: []Vector;
  numBeacons: int64;
  offset: Vector;
}

alias maxScanners = 32;
var scanners: [maxScanners]Scanner;
var numScanners: int64;

function readInput(): void {
  alias bufferSize = 16384;
  var buffer: [bufferSize]byte;
  var length = std.read(std.stdin, &buffer, bufferSize);
  if length == 0 { std.die("empty"); }
  if buffer[length - 1] != '\n' { std.die("newline"); }
  var i: []byte = &buffer;
  var end = i + length;
  var b: []Vector = &beacons;
  while i != end {
    if numScanners == maxScanners { std.die("too many scanners"); }
    if strings.strncmp(i, "--- scanner ", 12) != 0 { std.die("syntax"); }
    var id: int64;
    i = std.readInt(i + 12, &id);
    if id != numScanners { std.die("wrong scanner order"); }
    if strings.strncmp(i, " ---\n", 5) != 0 { std.die("syntax"); }
    var scanner = &scanners[numScanners];
    numScanners = numScanners + 1;
    i = i + 5;
    var first = numBeacons;
    while i != end && i[0] != '\n' {
      if numBeacons == maxBeacons { std.die("too many beacons"); }
      var beacon = &beacons[numBeacons];
      numBeacons = numBeacons + 1;
      i = std.readInt16(i, &beacon->x);
      if i[0] != ',' { std.die("expected ','"); }
      i = std.readInt16(i + 1, &beacon->y);
      if i[0] != ',' { std.die("expected ','"); }
      i = std.readInt16(i + 1, &beacon->z);
      if i[0] != '\n' { std.die("expected newline"); }
      i = i + 1;
    }
    scanner->beacons = b + first;
    scanner->numBeacons = numBeacons - first;
    if i == end { break; }
    if i[0] != '\n' { std.die("expected blank line"); }
    i = i + 1;
  }
}

function rotateX(v: Vector): Vector {
  var result: Vector;
  result.x = v.x;
  result.y = -v.z as int16;
  result.z = v.y;
  return result;
}

function rotateY(v: Vector): Vector {
  var result: Vector;
  result.x = -v.z as int16;
  result.y = v.y;
  result.z = v.x;
  return result;
}

function rotateZ(v: Vector): Vector {
  var result: Vector;
  result.x = -v.y as int16;
  result.y = v.x;
  result.z = v.z;
  return result;
}

function rotate(v: Vector, o: int64): Vector {
  var z = o % 4;
  if o < 16 {
    var x = o / 4;
    for var i = 0; i < x; i = i + 1 { v = rotateX(v); }
  } else {
    v = rotateY(v);
    if o < 20 { v = rotateY(rotateY(v)); }
  }
  for var i = 0; i < z; i = i + 1 { v = rotateZ(v); }
  return v;
}

function add(a: Vector, b: Vector): Vector {
  a.x = (a.x + b.x) as int16;
  a.y = (a.y + b.y) as int16;
  a.z = (a.z + b.z) as int16;
  return a;
}

function sub(a: Vector, b: Vector): Vector {
  a.x = (a.x - b.x) as int16;
  a.y = (a.y - b.y) as int16;
  a.z = (a.z - b.z) as int16;
  return a;
}

function equal(a: Vector, b: Vector): bool {
  return a.x == b.x && a.y == b.y && a.z == b.z;
}

struct Overlap {
  orientation: int64;
  offset: Vector;
}

struct HashTableNode {
  key: Vector;
  value: int64;
  next: *any;  // *HashTableNode
}

alias maxNodes = 1024;
var nodes: [maxNodes]HashTableNode;
var numNodes: int64;
alias bucketCount = 1024;
var table: [bucketCount]*HashTableNode;

function initTable(): void {
  for var i = 0; i < bucketCount; i = i + 1 { table[i] = null; }
  numNodes = 0;
}

function get(v: Vector): *HashTableNode {
  var hashKey = (v.x * 1009 + v.y * 2003 + v.z * 3001) % bucketCount;
  for var i = table[hashKey]; i != null; i = i->next as *HashTableNode {
    if equal(v, i->key) { return i; }
  }
  if numNodes == maxNodes { std.die("too many nodes"); }
  var node = &nodes[numNodes];
  numNodes = numNodes + 1;
  node->key = v;
  node->value = 0;
  node->next = table[hashKey];
  table[hashKey] = node;
  return node;
}

function findOverlap(a: *Scanner, b: *Scanner, overlap: *Overlap): bool {
  // Consider every possible orientation for scanner b relative to scanner a.
  for var orientation = 0; orientation < 24; orientation = orientation + 1 {
    // Consider every possible translational offset for scanner b.
    initTable();
    for var i = 0; i < b->numBeacons; i = i + 1 {
      var rotated = rotate(b->beacons[i], orientation);
      for var j = 0; j < a->numBeacons; j = j + 1 {
        var offset = sub(a->beacons[j], rotated);
        var cell = get(offset);
        cell->value = cell->value + 1;
        if cell->value >= 12 {
          overlap->orientation = orientation;
          overlap->offset = offset;
          return true;
        }
      }
    }
  }
  return false;
}

function part1(): int64 {
  for var i = 1; i < numScanners; i = i + 1 {
    // Find a scanner which overlaps with some previously handled scanner.
    var found = false;
    var index = -1;
    var overlap: Overlap;
    for var j = 0; j < i; j = j + 1 {
      for var k = i; k < numScanners; k = k + 1 {
        if findOverlap(&scanners[j], &scanners[k], &overlap) {
          found = true;
          index = k;
          break;
        }
      }
      if found { break; }
    }
    if !found { std.die("no match"); }
    // Rewrite all beacon positions in the reference coordinate frame.
    var s = scanners[index];
    s.offset = overlap.offset;
    scanners[index] = scanners[i];
    scanners[i] = s;
    for var j = 0; j < s.numBeacons; j = j + 1 {
      s.beacons[j] = add(rotate(s.beacons[j], overlap.orientation),
                         overlap.offset);
    }
  }
  var list = beacons;
  var numUnique = 0;
  for var i = 0; i < numBeacons; i = i + 1 {
    var found = false;
    for var j = 0; j < numUnique; j = j + 1 {
      if equal(list[i], list[j]) {
        found = true;
        break;
      }
    }
    if !found {
      list[numUnique] = list[i];
      numUnique = numUnique + 1;
    }
  }
  return numUnique;
}

function part2(): int64 {
  var maxDistance = 0;
  for var i = 0; i < numScanners; i = i + 1 {
    for var j = 0; j < numScanners; j = j + 1 {
      var offset = sub(scanners[i].offset, scanners[j].offset);
      var dx = offset.x > 0 ? offset.x : -offset.x;
      var dy = offset.y > 0 ? offset.y : -offset.y;
      var dz = offset.z > 0 ? offset.z : -offset.z;
      var distance = dx + dy + dz;
      if distance > maxDistance {
        maxDistance = distance;
      }
    }
  }
  return maxDistance;
}

function main(): int64 {
  readInput();
  std.printInt(part1());
  std.printInt(part2());
}
